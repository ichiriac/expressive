<?phpnamespace expressive {  defined('IS_WIN') or define('IS_WIN', substr(PHP_OS, 0, 1) === 'W');  if (IS_WIN) {    define('SOCK_TOKEN_CLOSE', "eos\r\n\r\n");  }  use Evenement\EventEmitter;  use React\EventLoop\Factory as Loop;  use React\Stream\Stream;  /**   * Cluster manager   */  class cluster extends EventEmitter {    public static $master = true;    public static $socket;    public static $loop;    public $port;    public $host;    public $workers;    /**     * Initialize a new cluster instance     */    public function __construct($port, $host = '127.0.0.1') {      $this->port = $port;      $this->host = $host;    }    /**     * Check if you are running into a master process     */    public function isMaster() {      return self::$master;    }    /**     * Check if you are currently running from a worker     */    public function isWorker() {      return !self::$master;    }    /**     * Starts to fork a new child process     */    public function fork() {      if (!self::$socket) {        self::$socket = stream_socket_server('tcp://' . $this->host . ':' . $this->port,  $errno, $errstr);        if (self::$socket === false) {          throw new \Exception(            'Could not listen on ' . $this->host . ':' . $this->port .' (' . $errno . ':' . $errstr . ')'          );        }        stream_set_blocking(self::$socket, 0);        if (IS_WIN) {          // handling requests from father only on windows mode          $busy = "HTTP/1.1 503 Service Unavailable\r\nContent-Length: 32\r\n\r\n<h1>503 Service Unavailable</h1>";          echo 'START SERVER' . "\n";          cluster::$loop->addReadStream(self::$socket, function() use($busy) {            //echo '<< Incoming client' . "\n";            $conn = stream_socket_accept(self::$socket);            //echo '<< client ' . $conn . "\n";            if ($conn) {              stream_set_blocking($conn, 0);              $conn = new Stream($conn, cluster::$loop);              $current = false;              // find any available client              foreach($this->workers as $w) {                if (!$w->pipe) {                  $current = $w;                  break;                }              }              // forward the message              if ($current) {                if ($current->pipe($conn)) {                  return;                }              }              // no available child, server is unavailable              echo 'Too busy !' . "\n";              $conn->end($busy);            }          });        }      }      $worker = new worker($this);      $worker->on('debug', function($data) {        echo '>> DEBUG : ' . $data . "\n";      });      $worker->on('error', function($data) {        echo '>> ERROR : ' . $data . "\n";      });      $worker->on('exit', function($code, $signal) use($worker) {        $this->emit('exit', array($worker, $code, $signal));        unset($this->workers[$worker->pid]);        if (empty($this->workers)) {          $this->close();        }      });      $this->workers[$worker->pid] = $worker;      return $this;    }    /**     * Closing the current cluster instance     */    public function close() {      if (!empty($this->workers)) {        foreach($this->workers as $w) $w->close();      }      self::$loop->stop();    }  }  // STATIC :  cluster::$master = !in_array('--slave', $_SERVER['argv']);  if (!cluster::$master) {    cluster::$socket = STDIN;  }  cluster::$loop = Loop::create();  register_shutdown_function(function() {    echo '>> APP IS RUNNING' . "\n";    cluster::$loop->run();  });}