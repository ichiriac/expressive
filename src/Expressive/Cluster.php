<?php/** * Expressive - cluster implementation * @author Ioan CHIRIAC * @license MIT */namespace Expressive {  /**   * Cluster manager   */  class Cluster extends Proxy\Server {    /**     * The full busy message when no worker is available (used only in windows mode)     */    public static $busy = "HTTP/1.1 503 Service Unavailable\r\nContent-Length: 32\r\n\r\n<h1>503 Service Unavailable</h1>";    /**     * Checks if currently running from a master or a worker process     */    public static $master = true;     /**     * handling cluster instance counter     */    private static $cur = 0;    /**     * Exit callback     */    private $onExit;    /**     * Current cluster instance if executed from a worker     */    public static $cid = null;    /**     * The main loop     */    public static $mainLoop;    /**     * Current cluster id (MUST be the same in master or worker modes)     */    public $id;    /**     * The server instance     */    public $server;    /**     * Initialize a new cluster instance     */    public function __construct($port, $host = '127.0.0.1') {      $this->id = ++self::$cur;      if ($this->isWorker()) {        // creates the worker socket        $this->port = intval($_SERVER['argv'][array_search('--slave', $_SERVER['argv']) + 2]);        $this->server = new Http\Server(          IS_WIN ? 'tcp://127.0.0.1:'.$this->port : STDIN, self::$mainLoop        );      } else if ($this->isMaster()) {        parent::__construct($port, $host);      }    }    /**     * Listen for a worker exit     */    public function onExit(callable $fn) {      if (!$this->isMaster()) {        throw new \Exception(          'You can only define an exit listener only from the master process (use isMaster)'        );      }      $this->onExit = $fn;    }    /**     * Alias for the server onRequest property     */    public function onRequest(callable $fn) {      if (!$this->isWorker()) {        throw new \Exception(          'You can only define a request handler from a worker process (use isWorker)'        );      }      $this->server->onRequest = $fn;      return $this;    }    /**     * Check if you are running into a master process     */    public function isMaster() {      return self::$master;    }    /**     * Check if you are currently running from a worker     */    public function isWorker() {      return !self::$master && $this->id === self::$cid;    }    /**     * Starts to fork a new child process     */    public function fork() {      if (!$this->isMaster()) {        throw new \Exception(          'You can only fork process from the master mode (use isMaster)'        );      }      // creating a new worker      $worker = new Worker($this);      $worker->onDebug(function($output) use($worker) {        fwrite(STDOUT, "\n" . '[' . $worker->pid . ']' . "\tDEBUG@" . date('Y-md-d H:i:s') . "\t" . trim($output) . "\n");      });      $worker->onError(function($output) use($worker) {        fwrite(STDERR, "\n" . '[' . $worker->pid . ']' . "\tERROR@" . date('Y-md-d H:i:s') . "\t" . trim($output) . "\n");      });      $worker->onExit(function($code, $signal) use($worker) {        unset($this->workers[$worker->pid]);        if ($this->onExit) {          call_user_func_array(            $this->onExit,            array($worker, $code, $signal)          );        }        if (empty($this->workers)) {          $this->close();        }      });      $this->workers[$worker->pid] = $worker;      return $this;    }    /**     * Closing the current cluster instance     */    public function close() {      if ($this->isMaster()) {        if (!empty($this->workers)) {          foreach($this->workers as $w) $w->close();        }        $this->workers = array();        parent::close();      } else if ( $this->isWorker() ) {        $this->server->close();      } else {        throw new \Exception(          'Call object action from the bad context, use isMaster or isWorker'        );      }      return $this;    }  }  // STATIC EXECUTION :  defined('IS_WIN') or define('IS_WIN', substr(PHP_OS, 0, 1) === 'W');  if (IS_WIN) {    define('SOCK_TOKEN_CLOSE', "@eos@");  }  Cluster::$mainLoop = new Socket\Loop();  Cluster::$cid = array_search('--slave', $_SERVER['argv']);  Cluster::$master = Cluster::$cid === false;  if (!Cluster::$master) {    Cluster::$cid = intval($_SERVER['argv'][Cluster::$cid + 1]);  }  // automatically run  register_shutdown_function(function() {    if (Cluster::$mainLoop) {      Cluster::$mainLoop->start();    }  });}