<?php/** * Expressive - reactphp cluster implementation * @author Ioan CHIRIAC * @license MIT */namespace Expressive {  use React\EventLoop\LoopInterface;  use React\Stream\Stream;  /**   * Cluster manager   */  class Cluster extends Http\Server {    /**     * The full busy message when no worker is available (used only in windows mode)     */    public static $busy = "HTTP/1.1 503 Service Unavailable\r\nContent-Length: 32\r\n\r\n<h1>503 Service Unavailable</h1>";    /**     * Checks if currently running from a master or a worker process     */    public static $master = true;     /**     * handling cluster instance counter     */    private static $cur = 0;    /**     * Current cluster instance if executed from a worker     */    public static $cid = null;    /**     * The main loop     */    public $loop;    /**     * The port used for listening     */    public $port;    /**     * The binded ip address     */    public $host;    /**     * List of current workers     */    public $workers;    /**     * Current cluster id (MUST be the same in master or worker modes)     */    public $id;    /**     * Currently binded socket     */    public $socket;    /**     * Initialize a new cluster instance     */    public function __construct(LoopInterface $loop, $port, $host = '127.0.0.1') {      $this->id = ++self::$cur;      $this->port = $port;      $this->host = $host;      $this->loop = $loop;      $this->workers = array();      if ($this->isWorker()) {        // creates the worker socket        if (IS_WIN) {          $this->port = intval($_SERVER['argv'][array_search('--slave', $_SERVER['argv']) + 2]);          $this->socket = new Http\Server(new Server($this));          // forward the request message          $this->socket->on('request', function($req, $res) {            if (!$this->listeners('request')) {                $req->end();                return;            }            $this->emit('request', array($req, $res));          });        } else {          $this->socket = new Server($this);          parent::__construct($this->socket);        }      } else {        // handle the master socket        $this->socket = stream_socket_server('tcp://' . $this->host . ':' . $this->port,  $errno, $errstr);        if ($this->socket === false) {          throw new \Exception(            'Could not listen on ' . $this->host . ':' . $this->port .' (' . $errno . ':' . $errstr . ')'          );        }        stream_set_blocking($this->socket, 0);        // handling requests from father only on windows mode        if (IS_WIN) {          $this->loop->addReadStream($this->socket, function($server) {            $conn = stream_socket_accept($server);            if ($conn) {              stream_set_blocking($conn, 0);              $conn = new Stream($conn, $this->loop);              $worker = false;              // find any available client              foreach($this->workers as $w) {                if (!$w->pipe) {                  $worker = $w;                  break;                }              }              // forward the message              if ($worker && $worker->pipe($conn)) return;              // no available worker, server is unavailable              $conn->end(Cluster::$busy);            }          });        }      }    }    /**     * Check if you are running into a master process     */    public function isMaster() {      return self::$master;    }    /**     * Check if you are currently running from a worker     */    public function isWorker() {      return !self::$master && $this->id === self::$cid;    }    /**     * Starts to fork a new child process     */    public function fork() {      if (!$this->isMaster()) {        throw new \Exception(          'You can only fork process from the master mode'        );      }      // creating a new worker      $worker = new Worker($this);      $worker->on('debug', function($output) use($worker) { fwrite(STDOUT, "\n" . '[' . $worker->pid . ']' . "\tDEBUG@" . date('Y-md-d H:i:s') . "\t" . trim($output) . "\n"); });      $worker->on('error', function($output) use($worker) { fwrite(STDERR, "\n" . '[' . $worker->pid . ']' . "\tERROR@" . date('Y-md-d H:i:s') . "\t" . trim($output) . "\n"); });      $worker->on('exit', function($code, $signal) use($worker) {        unset($this->workers[$worker->pid]);        $this->emit('exit', array($worker, $code, $signal));        if (empty($this->workers)) {          $this->close();        }      });      $this->workers[$worker->pid] = $worker;      return $this;    }    /**     * Closing the current cluster instance     */    public function close() {      if (!empty($this->workers)) {        foreach($this->workers as $w) $w->close();      }      $this->workers = array();    }    /**     * Starts to listen     */    public function listen($port = null, $host = '127.0.0.1') {      if (!$this->isWorker()) {        throw new \Exception(          'Could not listen, use Cluster->isWorker() to listen only from worker mode'        );      }      $this->socket->listen($this->port, $this->host);      return $this;    }  }  // STATIC EXECUTION :  defined('IS_WIN') or define('IS_WIN', substr(PHP_OS, 0, 1) === 'W');  if (IS_WIN) {    define('SOCK_TOKEN_CLOSE', "@eos@");  }  Cluster::$cid = array_search('--slave', $_SERVER['argv']);  Cluster::$master = Cluster::$cid === false;  if (!Cluster::$master) {    Cluster::$cid = intval($_SERVER['argv'][Cluster::$cid + 1]);  }}